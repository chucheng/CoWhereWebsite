import os
import logging
import pprint
import datetime
import json
import socket

import tornado.ioloop
import tornado.web
from tornado.options import define, options

import Util

PRODUCTION_MODE = False

#chucheng: set PRODUCTION_MODE to false for debugging

#######################
#Default Configuration#
#######################

LOG_FILE = './static/AirBridge.log'
SERVER_PORT = 80 if PRODUCTION_MODE else 99

TIMEOUT_EMPTY_SESSION=600 #seconds
TIMEOUT_LONG_SESSION=1    #days
LOCAL_SERVER_PREFIX = ("http://" + socket.gethostbyname(socket.gethostname()) 
                       + ":" + str(SERVER_PORT) + "/")
PRODUCTION_SERVER_PREFIX = ("http://" + "184.169.151.213"
                            + ":" + str(SERVER_PORT) + "/")
SERVER_PREFIX = PRODUCTION_SERVER_PREFIX if PRODUCTION_MODE else LOCAL_SERVER_PREFIX

#logging.basicConfig(filename=LOG_FILE, level=logging.info)
#logging.basicConfig(level=logging.info) #show log to screen
logger = Util.getPrettyLogger(LOG_FILE, "AirBridge.py")

define("port", default=SERVER_PORT, help="run on the default port", type=int)                  
#define("timeout_long_session", default=1, 
       #help="remove the session if it's more than 1 day", type=int)

class Application(tornado.web.Application):
    def __init__(self):
        handlers = [
            (r"/", MirrorHandler), #Send whatever he get
            (r"/r/", RecieverHandler),
            (r"/f/", FileUrlLookUpHandler),
            (r"/s/", SenderHandler),
            (r"/c/", CreatorHandler),
            (r"/a/", AdminHandler), #Administration
            (r"/view_log/", LogViewHandler),
            (r"/replay/", ReplayHandler),
        ]
        settings = dict(
            cookie_secret="1yKE2Q1vSn+uZ3lEt7pruTvv2lRF204PqASwpD3AXu4=",
            # generated by
            #   base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes) 
            login_url="/auth/login",
            template_path=os.path.join(os.path.dirname(__file__), "templates"),
            static_path=os.path.join(os.path.dirname(__file__), "static"),
            xsrf_cookies=True,
            autoescape="xhtml_escape",
        )
        tornado.web.Application.__init__(self, handlers, **settings)
        logger.info("Start the server.")
        
class LogViewHandler(tornado.web.RequestHandler):
    def get(self):        
        keyword = self.get_argument("filter", default="")        
        f = open(LOG_FILE)
        lines = f.readlines()
        f.close()
        self.write("<HTML><HEAD></HEAD><BODY>")
        self.write("""<table border="1">""")
        for line in lines:
            if not line:
                continue
            if keyword and keyword not in line:
                continue
            self.write("&nbsp;<tr>\n")
            for field in line[:-1].split('\t'):
                self.write("&nbsp;&nbsp;<td>\n")
                self.write(field)
                self.write("&nbsp;&nbsp;</td>\n")
            self.write("&nbsp;<tr>\n")
        self.write("""</table>""")
        self.write("</BODY></HTML>")

class ReplayHandler(tornado.web.RequestHandler):
    def get(self):        
        session_id = self.get_argument("s", default="")   
        style = self.get_argument("t", default="json")
                
        f = open(LOG_FILE)
        lines = f.readlines()
        f.close()
        
        rsp_obj = []
        
        if style == "table":
            self.write("<HTML><HEAD></HEAD><BODY>")
            self.write("""<table border="1">""")
        for line in lines:
            if not line:
                continue
            fields = line[:-1].split('\t')
            if len(fields) < 4: 
                continue
            msg_time = fields[0]
            msg_field = fields[2] 
            session_id_field = fields[3]
            pre_fix = "AirBridge.py - Broadcast complete: "
            if session_id_field == session_id and msg_field.startswith(pre_fix):
                broadcast_msg = msg_field[len(pre_fix):]
            else:
                continue
            
            if style == "table":
                self.write("&nbsp;<tr>\n")
                self.write("&nbsp;&nbsp;<td>\n")
                self.write(msg_time)
                self.write("&nbsp;&nbsp;</td>\n")            
                self.write("&nbsp;&nbsp;<td>\n")
                self.write(broadcast_msg)
                self.write("&nbsp;&nbsp;</td>\n")
                self.write("&nbsp;<tr>\n")
            else:
                rsp_obj.append([msg_time, broadcast_msg])
            
        if style == "table":
            self.write("""</table>""")
            self.write("</BODY></HTML>")        
        else:            
            json_msg = json.dumps(rsp_obj) + "\n"
            self.write(json_msg.replace("\n", "\\n"))
            logger.error(json_msg.replace("\n", "\\n") + "\t" + session_id)             

class BaseHandler(tornado.web.RequestHandler):       
    #def output(self, server_code, message, log_level=logging.INFO, log_exception=False):
        #logfunc = None
        #if(log_level==logging.INFO):
            #logfunc = logger.info
        #elif(log_level==logging.DEBUG):
            #logfunc = logger.debug
        #elif(log_level==logging.WARNING):
            #logfunc = logger.warn
        #elif(log_level==logging.ERROR):
            #logfunc = logger.error
        #elif(log_level==logging.CRITICAL):
            #logfunc = logger.critical
        #else:
            #logger.critical("Unknown Log Level: " + str(log_level))
            
        
        #logfunc(message, exc_info=log_exception)
        #self.write('{{"{0}":"{1}"}}\r\n'.format(server_code, message))
        #self.flush()
    pass
            

class ClientPool(object):
    client_callbacks = dict() # { session_id: set(__connection__) }    
    session_timestamp = dict() # { session_id: time}
    session_info = dict() #{ session_id : dict() }
    # create_at -- by CreatorHandler
    # owner = some connection id by RecieverHandler
    # clients = a set of connection id by RecieverHandler
    # file_url = the file url for this session
    
    session_id_lookup_by_callback = dict() # { callback: session_id}
    connection_id_lookup_by_callback = dict() # { callback: session_id}
    
    def init_session(self, session_id, file_url):
        """Create a virtual room(session) for discussion.
        
        """
        cls = ClientPool
        if session_id in cls.client_callbacks.keys():
            logger.error("The session alread exists! (ID:{0})".format(session_id))
        else:
            now = datetime.datetime.now()            
            cls.session_info[session_id] = dict()
            cls.session_info[session_id]["create_at"] = now
            cls.session_info[session_id]["file_url"] = file_url
            cls.client_callbacks[session_id] = list()
            
    
    def join(self, callback, session_id, conn_id):
        cls = ClientPool
        #if session_id not in cls.client_callbacks.keys():
            #logging.error("The session does not exist! (ID:{0})".format(session_id),
                          #exc_info=True)
        #else:  

        if callback not in cls.client_callbacks:
            cls.client_callbacks[session_id].append(callback)  
            cls.session_id_lookup_by_callback[callback] = session_id
            cls.connection_id_lookup_by_callback[callback] = conn_id
        else:
            msg = "The client is arealy in the session."
            json_msg = Util.getSimpleJson("Ok", msg)
            logger.error(json_msg.replace("\n", "\\n") + "\t" + session_id)            
            return False
        return True
    
            #TODO: this part is very dangerous becuz you assume the instance
            #      is an tornado.web.RequestHandler
            #self.write('{{"Error", {0})}}\n'.format(msg))
            #self.flush()             
                
      
        
    def leave(self, callback):
        cls = ClientPool
        callback(messages="", close_resp=True)
        #Delete the lookup table
        session_id = cls.session_id_lookup_by_callback.get(callback, None)
        if session_id:
            del cls.session_id_lookup_by_callback[callback]
        conn_id = cls.connection_id_lookup_by_callback.get(callback, None)
        if conn_id:
            del cls.connection_id_lookup_by_callback[callback]
            
        #Remove call back and then update session info in cls.session_info
        if session_id in cls.client_callbacks.keys():
            cls.client_callbacks[session_id].remove(callback)
            #Owner
            cls.session_info[session_id]["clients"].remove(conn_id)
            if conn_id == cls.session_info.get("owner"):
                cls.session_info[session_id]["owner"] = cls.session_info[session_id].get("clients").pop() 
                ls.session_info[session_id]["clients"].add(cls.session_info[session_id].get("owner"))
                #pop() will remove the client so you have to add it back                
        else:
            logging.warning("Cannot find session_id in session_id_lookup_by_callback")
            for sid in cls.client_callbacks.keys():
                logging.warning("Try a global memory search .")
                if cb in cls.client_callbacks[sid]:
                    cls.client_callbacks[sid].remove(cb)
                    #TODO: deal with owner issue
                    break
        msg = "You (conection id: {1}) have leave session:{0}.".format(
            session_id,            
            conn_id
            )
        json_msg = Util.getSimpleJson("Ok", msg)
        logger.info(json_msg.replace("\n", "\\n") + "\t" + session_id)
                
    def broadcast(self, messages, session_id, connection_id):
        """Broadcase message to every client, return false if session_id is invalid"""
        cls = ClientPool
        if session_id not in cls.client_callbacks.keys():
            logger.error("The session does not exist! (ID:{0})".format(session_id)
                         + "\t" + session_id) 
            return False
        else:
            for callback in cls.client_callbacks[session_id]:
                try:
                    callback(messages + "\n", session_id, connection_id)
                except:
                    logger.error("Error in client callback"
                                 + "\t" + session_id,
                                 exc_info=True)                    
            return True
                    
    def shutdown_all_clients(self):
        cls = ClientPool
        for session_id in cls.client_callbacks.keys():
            for callback in cls.client_callbacks[session_id]:
                callback(messages="", close_resp=True)
            cls.client_callbacks[session_id] = set() #remove all call backs  
        
class CreatorHandler(BaseHandler, ClientPool): 
    """Create a meeting section by providing a file url.
    
    Send to Client {"Ok", SERVER_PREFIX + "r/?s=" + random_six}    
    """
    def get(self):
        cls = ClientPool
        
        random_six = Util.sixCharRandom() if PRODUCTION_MODE else 'abcdef'    
        
        #Regenerate hex until it's not in the pool
        while random_six in cls.client_callbacks.keys():
            msg = "The session alread exists! (ID:{0})".format(random_six)
            self.output("Warn", msg, logging.WARN)
            random_six = Util.sixCharRandom()
            
        file_url = self.get_argument("fileurl")
        logger.info("GET /c/?fileurl=" + file_url 
                    + "\t" + random_six
                    + "\tFROM:" + self.request.remote_ip )
        #TODO: check whether a url exists via httplib        
        
        self.init_session(random_six, file_url)
        
        
        listen_url = SERVER_PREFIX + "r/?s=" + random_six + "&u="  
        session_id = random_six
        rsp_obj = dict()
        rsp_obj["listen_url"] = listen_url
        rsp_obj["session_id"] = session_id
        json_msg = json.dumps({"Ok":rsp_obj}) + "\n"
        #json_msg = Util.getSimpleJson("Ok", msg) #with addition \n at the end
        
        logger.info("Sent: " + json_msg.replace("\n", "\\n")
                    + "\t" + random_six
                    + "\tTO:" + self.request.remote_ip )
        self.write(json_msg)
        self.finish()                        
        

class MirrorHandler(tornado.web.RequestHandler):
    @tornado.web.asynchronous
    def get(self):
        arguments = self.get_arguments()
        self.output("Ok", str(arguments))

class ValidCheck(object):
    @staticmethod
    def username(s):
        return str(s).isalnum();
        

class AdminHandler(BaseHandler, ClientPool): 
    #TODO: need rewrite
    pp = pprint.PrettyPrinter(indent=2)
    def get(self):
        #TODO: check client ip, only accepted this call from localhost
        cls = ClientPool    
        
        self.write(str(len(cls.client_callbacks))+ "\n")
        cmd = self.get_argument("cmd")
        if cmd == "show_session":            
            msg = ""
            for k in cls.client_callbacks.keys():
                msg = msg + str(k) + ":" + str(len(cls.client_callbacks[k])) + ","
            self.write("Ok", msg)
            self.flush()
            
        elif cmd == "delete_log":
            msg = "Remove the log file: " + LOG_FILE
            #TODO: the following two lines are very bad idea, it won't recreate
            #      a usable log file. The log function stop after delete.
            #Solution: do not delete but make it pretty.
            os.remove(LOG_FILE)
            open(LOG_FILE, 'a').close() 
            self.output("Ok", msg)
            
        elif cmd == "clean_dead_session":                  
            outdated_sid = set()
            now = datetime.datetime.now()
            for session_id in cls.client_callbacks:
                #no timestamp
                if session_id not in cls.session_timestamp:
                    outdated_sid.add(session_id)                                    
                else:
                    sec_diff = (now - cls.session_timestamp.get(session_id)).seconds
                    day_diff = (now - cls.session_timestamp.get(session_id)).days
                    # empty session 
                    if sec_diff > TIMEOUT_EMPTY_SESSION and len(cls.client_callbacks.get(session_id))==0:
                        outdated_sid.add(session_id)
                    # long session
                    if day_diff > TIMEOUT_LONG_SESSION:
                        outdated_sid.add(session_id)
            # Terminate Connection
            for sid in outdated_sid:
                for cb in cls.client_callbacks[sid]:
                    self.leave(cb, sid)
            
            # Clean up
            for sid in outdated_sid:
                if sid in cls.client_callbacks.keys():
                    del cls.client_callbacks[sid]
                if sid in cls.session_timestamp.keys():
                    del cls.session_timestamp[sid]
        else:
            pass #invalid command
        
        #self.write("-->" + str(len(cls.client_callbacks)))

class FileUrlLookUpHandler(BaseHandler, ClientPool):    
    """LookUp FileUrl by session id"""
    def get(self):
        session_id = self.get_argument("s", default="")
        if not session_id:
            msg = 'GET paramet "s"(session) is missing!'                
            json_msg = Util.getSimpleJson("Error", msg)
            logger.info("Sent: " + json_msg.replace("\n", "\\n")
                        + "\t" + session_id)
            self.write(json_msg)
            self.finish()
            return    
    
        logger.info("GET /r/?s=" + session_id 
                    + "\t" + session_id
                    + "\tFROM:" + self.request.remote_ip
                    )    
        
        cls = ClientPool
        if session_id not in cls.client_callbacks.keys():
            msg = "The session does not exist! (ID:{0})".format(session_id)                                                  
            json_msg = Util.getSimpleJson("Error", msg)   
            logger.info("Sent: " + json_msg.replace("\n", "\\n"))
            self.write(json_msg)
            self.finish()
            return    
        else:
            info = cls.session_info[session_id] #a dict for storing session info            
            file_url = info.get("file_url")
            rsp_obj = dict()
            rsp_obj["Ok"] = file_url
            json_msg = json.dumps(rsp_obj) + "\n"
            logger.info("Sent: " + json_msg.replace("\n", "\\n")
                        + "\t" + session_id
                        + "\tTO:" + self.request.remote_ip )            
            self.write(json_msg)
            self.flush()  
            self.finish()
        

class RecieverHandler(BaseHandler, ClientPool):
    @tornado.web.asynchronous
    def get(self):
        session_id = self.get_argument("s", default="")
        username = self.get_argument("u", default="")
        
        if not session_id:
            msg = 'GET paramet "s"(session) is missing!'                
            json_msg = Util.getSimpleJson("Error", msg)
            logger.info("Sent: " + json_msg.replace("\n", "\\n")
                        + "\t" + session_id)
            self.write(json_msg)
            self.finish()
            return
        
        if not username:
            msg = 'GET paramet "u"(username) is missing!'                
            json_msg = Util.getSimpleJson("Error", msg)
            logger.info("Sent: " + json_msg.replace("\n", "\\n")
                        + "\t" + session_id)
            self.write(json_msg)
            self.finish()     
            return
            
        logger.info("GET /r/?s=" + session_id + "&u=" + username 
                    + "\t" + session_id
                    + "\tFROM:" + self.request.remote_ip
                    )        
            
        cls = ClientPool
        if session_id not in cls.client_callbacks.keys():
            msg = "The session does not exist! (ID:{0})".format(session_id)                                                  
            json_msg = Util.getSimpleJson("Error", msg)   
            logger.info("Sent: " + json_msg.replace("\n", "\\n"))
            self.write(json_msg)
            self.finish()
            return
        else:    
            info = cls.session_info[session_id] #a dict for storing session info            
            conn_id = Util.tenCharRandom() if PRODUCTION_MODE else 'a123456789'             
            
            if "owner" not in info.keys(): #first participant
                info["owner"] = conn_id
                logger.info("Adding a owner [{0}] to session [{1}]".format(
                    conn_id, session_id)
                            + "\t" + session_id
                            )
                info["clients"] = set()
                info["clients"].add(conn_id)
            else:
                while conn_id in info["clients"]:
                    conn_id = Util.tenCharRandom()
                info["clients"].add(conn_id)
            logger.info("Adding a client [{0}] to session [{1}]".format(
                conn_id, session_id) + "\t" + session_id)
                                                               
            join_success = self.join(self.on_new_messages, session_id, conn_id)    
            if not join_success:
                msg = "Joining failed!"
                json_msg = Util.getSimpleJson("Error", msg)
                logger.info("Sent: " + json_msg.replace("\n", "\\n")
                            + "\t" + session_id
                            + "\tTO:" + self.request.remote_ip )                
            
            copy_of_info = dict()
            for k in info:              
                copy_of_info[k] = str(info[k])
                          
            logger.info("Session: " + json.dumps(copy_of_info[k]).replace("\n", "\\n")
                        + "\t" + session_id )
            rsp_obj = dict()
            rsp_obj["connection_id"] = conn_id
            rsp_obj["file_url"] = info.get("file_url")
            ok_obj = dict()
            ok_obj["Ok"] = rsp_obj
            json_msg = json.dumps(ok_obj) + "\n"
            ten_json_msg = json_msg*50
            
            logger.info("Sent: " + json_msg.replace("\n", "\\n") + "* 50 times."
                        + "\t" + session_id
                        + "\tTO:" + self.request.remote_ip )            
            self.write(ten_json_msg)
            self.flush()
        
    def on_new_messages(self, messages, session_id="", connection_id="", close_resp=False):
        # connection is closed
        if self.request.connection.stream.closed():
            logger.error("Stop sending becuz the connection (id: {0}) is closed.".format(connection_id)        
                        + "\t" + session_id
                        + "\tTO:" + self.request.remote_ip ) 
            return
        self.write(messages)
        logger.info("Sent message to the connection (id: {0}) - ".format(connection_id)        
                    + messages.replace("\n", "\\n")
                    + "\t" + session_id
                    + "\tTO:" + self.request.remote_ip )         
        self.flush()
        if close_resp:
            self.finish()        
    
    #called when client closed the connection
    def on_connection_close(self):
        self.leave(self.on_new_messages)        
        pass    
        
class SenderHandler(BaseHandler, ClientPool):
    """
    If message == {"Command": "CleanUp"}, you remove all session.
    
    Example
    http://localhost:99/s/?s=5afc36&c=connectionid&b={"HelloWorld":"All"}
    """
    def get(self):
        session_id = self.get_argument("s", default="")
        connection_id = self.get_argument("c", default="")
        msg_all = self.get_argument("b", default="")
        
        if not session_id:
            msg = 'GET paramet "s"(session) is missing!'                
            json_msg = Util.getSimpleJson("Error", msg)
            logger.info("Sent: " + json_msg.replace("\n", "\\n")
                        + "\t" + session_id)
            self.write(json_msg)
            self.finish()
            return
        
        if not connection_id:
            msg = 'GET paramet "c"(connection_id) is missing!'                
            json_msg = Util.getSimpleJson("Error", msg)
            logger.info("Sent: " + json_msg.replace("\n", "\\n")
                        + "\t" + session_id)
            self.write(json_msg)
            self.finish()     
            return
        if not msg_all:
            msg = 'GET paramet "b"(message for all) is missing!'                
            json_msg = Util.getSimpleJson("Error", msg)
            logger.info("Sent: " + json_msg.replace("\n", "\\n")
                        + "\t" + session_id)
            self.write(json_msg)
            self.finish()     
            return        
                
        logger.info("GET /r/?s=" + session_id + "&c=" + connection_id 
                    + "&m=" + msg_all
                    + "\t" + session_id                     
                    + "\tFROM:" + self.request.remote_ip
                    )           

        try:
            msg_obj = json.loads(msg_all)
        except ValueError:
            msg = ("No broadcast because the message" 
                   + "is not a json format string: " 
                   + msg_all)                        
            json_msg = Util.getSimpleJson("Error", msg)
            logger.error("Sent: " + json_msg.replace("\n", "\\n")
                         + "\t" + session_id)
            self.write(json_msg)
            self.finish()   
            return
        
        #TODO: Special case here
        if "Command" in msg_obj.keys():
            if msg_obj["Command"] == "CleanUp":
                self.shutdown_all_clients()
                return
                   
        b_success = self.broadcast(msg_all, session_id, connection_id)
        if b_success: 
            rsp_msg = "Broadcast complete: " + msg_all.replace("\n", "\\n").replace('"', '\\"')      
            logger.info(rsp_msg + "\t" + session_id)        
            json_rsp_msg = Util.getSimpleJson("Ok", rsp_msg)
            self.write(json_rsp_msg)        
        else:
            rsp_msg = "Broadcast fail: the session id ({0}) does not exist!".format(session_id)
            logger.error(rsp_msg + "\t" + session_id)        
            json_rsp_msg = Util.getSimpleJson("Error", rsp_msg)
            self.write(json_rsp_msg)             
        

application = tornado.web.Application([

])


def main():
    tornado.options.parse_command_line()
    app = Application()
    app.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()

if __name__ == "__main__":
    main()
