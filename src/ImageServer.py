import os
import logging
import datetime
import json
import socket

import tornado.ioloop
import tornado.web
from tornado.options import define, options

import Util

PRODUCTION_MODE = True 

#chucheng: set PRODUCTION_MODE to false for debugging



#######################
#Default Configuration#
#######################

LOG_FILE = './static/AirBridge.log'
SERVER_PORT = 80 if PRODUCTION_MODE else 99

LOCAL_SERVER_PREFIX = ("http://" + socket.gethostbyname(socket.gethostname()) 
                 + ":" + str(SERVER_PORT) + "/")
PRODUCTION_SERVER_PREFIX = ("http://" + "184.169.156.73"
                 + ":" + str(SERVER_PORT) + "/")
SERVER_PREFIX = PRODUCTION_SERVER_PREFIX if PRODUCTION_MODE else LOCAL_SERVER_PREFIX

logger = Util.getPrettyLogger(LOG_FILE, "ImageServer.py")

define("port", default=SERVER_PORT, help="run on the default port", type=int)                  
#define("timeout_long_session", default=1, 
       #help="remove the session if it's more than 1 day", type=int)

class Application(tornado.web.Application):
    def __init__(self):
        handlers = [
            (r"/", PortalHandler),
            (r"/u/", UploadHandler), #Send whatever he get
        ]
        settings = dict(
            cookie_secret="BAE/FPjBS2O4wUUg1nFO2efsNj1Oz0xTqptBRdya3zQ=",
            # generated by
            #   base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes) 
            login_url="/auth/login",
            template_path=os.path.join(os.path.dirname(__file__), "templates"),
            static_path=os.path.join(os.path.dirname(__file__), "static"),
            xsrf_cookies=False,
            autoescape="xhtml_escape",
        )
        tornado.web.Application.__init__(self, handlers, **settings)
        logger.info("Start the server.")
        
class BaseHandler(tornado.web.RequestHandler):    
    pass

class PortalHandler(BaseHandler): 
    def get(self):
        self.redirect('static/index.html')

class UploadHandler(BaseHandler): 
    """    
    """
    def post(self):
        
        str_time_suffix = datetime.datetime.now().strftime("_%Y%m%d_%H%M%S")
        #'_20120420_140745'

        #make sure file exist
        if "file" not in self.request.files.keys():
            msg = 'The "file" attribute does not exists'
            json_msg = Util.getSimpleJson("Error", msg)
            logger.error(json_msg.replace("\n", "\\n"))
            self.write(json_msg)
            self.finish()
            return
                        
        photofile = self.request.files['file'][0]
        filename = photofile['filename']
        
        # .jpg?
        if not (filename.lower().endswith(".jpg") or 
                filename.lower().endswith(".pdf")):
            msg = 'The file may not be a jpg nor a pdf file.'
            json_msg = Util.getSimpleJson("Error", msg)
            logger.error(json_msg.replace("\n", "\\n"))
            self.write(json_msg)
            self.finish()
            return    
        
        if filename.lower().endswith(".pdf"):
            new_filename_pdf = filename[:-4] + str_time_suffix + ".pdf"
            output_file = open("./static/pdf/" + new_filename_pdf, 'w')
            output_file.write(photofile['body'])
            output_file.close()                        
        else:        
            new_filename = filename[:-4] + str_time_suffix + ".jpg"
                
            output_file = open("./static/jpg/" + new_filename, 'w')
            output_file.write(photofile['body'])
            output_file.close()
                
            #msg = 'File: {0} ==> Saved to {1}'.format(photofile['filename'], 
                                                  #photofile['filename']+str_time_suffix
                                                  #)
                    
            new_filename_pdf = filename[:-4] + str_time_suffix + ".pdf"
            cmd = "convert {0} -rotate 90 {1}".format(
                "./static/jpg/"+ new_filename, 
                "./static/pdf/"+ new_filename_pdf)
            msg_convert = os.system(cmd)
            logger.info("running convert..." + str(msg_convert))
        
        msg = SERVER_PREFIX + "static/pdf/" + new_filename_pdf
        json_msg = Util.getSimpleJson("Ok", msg)        
        logger.info(json_msg.replace("\n", "\\n"))
        self.write(json_msg)
        self.finish()
        
        
        """
        cls = ClientPool
        
        random_six = Util.sixCharRandom() if PRODUCTION_MODE else 'abcdef'    
        
        #Regenerate hex until it's not in the pool
        while random_six in cls.client_callbacks.keys():
            msg = "The session alread exists! (ID:{0})".format(session_id)
            self.output("Warn", msg, logging.WARN)
            random_six = Util.sixCharRandom()
            
        file_url = self.get_argument("fileurl")
        logger.info("GET /c/?fileurl=" + file_url 
                    + "\t" + random_six
                    + "\tFROM:" + self.request.remote_ip )
        #TODO: check whether a url exists via httplib        
        
        self.init_session(random_six)
        msg = SERVER_PREFIX + "r/?s=" + random_six + "&u="  
        json_msg = Util.getSimpleJson("Ok", msg) #with addition \n at the end
        logger.info("Sent: " + json_msg.replace("\n", "\\n")
                    + "\t" + random_six
                    + "\tTO:" + self.request.remote_ip )
        self.write(json_msg)
        self.finish()         
        """

application = tornado.web.Application([

])


def main():
    tornado.options.parse_command_line()
    app = Application()
    app.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()

if __name__ == "__main__":
    main()
